---
title: "Selecting Biomarkers and Making Predictions"
author: "Dario Strbenac"
date: "29 June 2018"
output:
  html_document:
    code_folding: hide
    number_sections: yes
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 1
    theme: yeti
editor_options: 
  chunk_output_type: console
---

```{r, echo = FALSE}
library(knitr)
#opts_knit[["set"]](root.dir = "/home/dario/Documents/tutorial/")
options(width = 91)
```

# Activity Overview

- RNA-seq data set: Acute Myeloid Leukaemia treatment resistance

- Exploratory data analysis and visualisation

- Fitting widely used classifiers to a simple partition of the data set

# Preparation

To complete todays workshops you will need to have R and Rstudio installed on your computer. Please see README file for more information. 

You should create a directory for todays workshop to save all of your work.  

You should open a new rmarkdown (Rmd) document. You will write all of your code here.

You will also need to install the following R packages.

```{r}
source("https://bioconductor.org/biocLite.R")
biocLite("ClassifyR")
biocLite("DESeq2")
biocLite("vsn")
biocLite("genefilter")
install.packages('tidyverse')
install.packages('sparsediscrim')
install.packages('e1071')
```


# RNA-seq Data Set: Acute Myeloid Leukaemia (AML) Treatment Resistance

- Primary therapy resistance is a major problem in acute myeloid leukemia treatment. Approximately 20-30% of younger adult patients with AML and as many as 50% of older adults are refractory to induction treatment.

- Research findings are <a href="http://www.haematologica.org/content/103/3/456" target="_blank">published</a> in *Haematologica* in 2018.

- The data is available from <a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE106291" target="_blank">GEO Browser</a> as 250 `txt.gz` files of gene-level read counts or a Microsoft Excel file where the gene expression values were standardised to have a mean of 0 and variance of 1.

# Data Import and Exploration {.tabset .tabset-fade .tabset-pills}

Importing RNA-seq data from GEO Browser into R is a difficult process. Import the prepared tab-separated text files of RNA-seq read counts and clinical data from GitHub.

## Import Prepared Files From GitHub 

```{r}
readCounts <- read.delim(url("https://raw.githubusercontent.com/SydneyBioX/localWorkshop/master/data/counts.txt"), check.names = FALSE)
readCounts <- as.matrix(readCounts)
sampleInfo <- read.delim(url("https://raw.githubusercontent.com/SydneyBioX/localWorkshop/master/data/samples.txt"), check.names = FALSE)
```

`check.names = FALSE` prevents R unnecessarily changing hyphens and spaces in column names to periods.


## The Clinical Data

The clinical data provides information about several different characteristics of the patients. Verify that there is data for 250 patients.<br>
**Hint**: `sampleInfo` is a `data.frame`. Each row stores data for one patient.

```{r}
head(sampleInfo)
nrow(sampleInfo)
```

Observe the number of samples which are resistant to treatment and which are not.

```{r}
table(sampleInfo[, "Response"])
```

$164 + 71 = 235$, so there are 15 patients with missing data regarding their resistance. Identify which rows of the clinical data they are in and remove the samples.

```{r}
removeClinical <- which(is.na(sampleInfo[, "Response"]))
readCounts <- readCounts[, -removeClinical]
sampleInfo <- sampleInfo[-removeClinical, ]
```

Remove outcome variables other than Response from the clinical table.

```{r}
ignoreClinical <- match(c("ID", "Status", "Survival Time"), colnames(sampleInfo))
sampleInfo <-sampleInfo[, -ignoreClinical]
```


## Extension: Download and Format Tables From GEO

Unfortunately, standards and protocols for uploading gene expression data to repositories such as GEO have become very lax in recent years. Previously there were very clean and standardised ways to load data from GEO into R, however this is now often not the case. For completeness, below is the code that we used to download and load the AML data into R. Observe that the process is not streamlined, but do not run the code.

```{r, eval = FALSE}
library(GEOquery)
library(tools)

clinical <- pData(getGEO("GSE106291")[[1]])
keepColumns <- c("title", "characteristics_ch1.2", "characteristics_ch1.3",
                 "characteristics_ch1.4", "characteristics_ch1.5",
                 "characteristics_ch1.6", "characteristics_ch1.8",
                 "characteristics_ch1.9")
clinical <- clinical[, keepColumns]
colnames(clinical) <- c("ID", "Gender", "Age", "Response", "Survival Time", "Status",
                        "RUNX1-RUNX1T1 Fusion", "RUNX1 Mutation")
clinical <- data.frame(lapply(clinical, as.character),
                       check.names = FALSE, stringsAsFactors = FALSE)
removedColumnNames <- lapply(clinical, function(dataColumn)
                             toTitleCase(gsub(".*: ", '', dataColumn)))
clinical <- data.frame(removedColumnNames, check.names = FALSE)

library(readr)
tempFile <- file.path(tempdir(), "countsPack.tar")
download.file("https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE106291&format=file",
              destfile = tempFile)
untar(tempFile, exdir = dirname(tempFile))
countsFiles <- list.files(dirname(tempFile), "^GSM", full.names = TRUE)
sampleCounts <- lapply(countsFiles, function(file)
                       read_delim(file, '\t', col_names = FALSE))
countsMatrix <- do.call(cbind, lapply(sampleCounts, "[[", 2))
rownames(countsMatrix) <- sampleCounts[[1]][[1]]
colnames(countsMatrix) <- sapply(strsplit(basename(countsFiles), '_'), '[', 2)
```



# Properties of RNA-seq Measurements

RNA-seq count tables have a couple of properties which need to be accounted for.

1. Different samples may have a different total number of reads. A particular sample with 10 million reads will have 0 reads counted for genes that will have non-zero counts if the same sample had 100 million reads.

2. The variance of counts increases as the mean count increases when considering the trend based on all of the genes. Most classifiers require that the input data set have a constant variance across the range of means.

We will use the R package DESeq2 to transform our data to account for these to issues. This will follow many of the steps in the DESeq2 vignette https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html .

## Load counts into DESeq2 format

To use DESeq2 to transform our data, we will need to load it into a DESeq2 object.
```{r}

library("DESeq2")

# Convert our counts into a DESeqDataSet

dds <- DESeqDataSetFromMatrix(countData = readCounts,
                              colData = data.frame(colNames = colnames(readCounts)),
                              design = ~ 1)

```


While not necessary, we will remove all genes with zero counts in 200 or more samples.<br>
We will use `==` to test for zeros.

```{r}
keep <- rowSums(counts(dds) == 0) < 200
dds <- dds[keep,]
```


## Read Total / Library Size Differences

As typical for omics data and in contrast to clinical data, the genes are stored in rows and the samples in columns. Identify the number of genes and samples.<br>
**Hint**: Use either `dim` or `nrow` and `ncol` functions.

```{r}
readCounts[1:5, 1:5]
dim(readCounts)
```

The number of reads per sample varies widely betwen patients by as much as 10-fold.

```{r}
samplesCounts <- colSums(counts(dds))
countsSummary <- summary(samplesCounts)
countsSummary
```

The limit of detection would be quite different between samples. We can also visualise this with a boxplot where we see that the distribution of gene expression values of each sample look quite different.

```{r, fig.height = 6, fig.width = 12}
boxplot(counts(dds)[, 1:50], ylim = c(0, 1500),
        main = "Gene Counts", ylab = "Counts", cex = 0.25, xaxt = 'n')
```


We can alleviate this issue by scaling each column to have a similar number of counts. We will do this using the normalization procedure in DESeq2 `estimateSizeFactors`.


```{r}
dds <- estimateSizeFactors(dds)
```

Note how the disributions of counts per patient are now much more similar.

```{r, fig.height = 6, fig.width = 12}
boxplot(counts(dds, normalize=TRUE)[, 1:50], ylim = c(0, 1500),
        main = "Gene Counts", ylab = "Scaled Counts", cex = 0.25, xaxt = 'n')
```

## Increasing Mean and Variance

The variance of counts increases as the mean count increases when considering the trend based on all of the genes.

The Bioconductor package [EDASeq](https://bioconductor.org/packages/release/bioc/html/EDASeq.html) contains function for **e**xploratory **d**ata **a**nalysis of RNA-**seq**. Observe the mean-variance relationship of the scaled counts.<br>
**Hint**: EDASeq doesn't work with a matrix, but a `SeqExpressionSet` object. Read the documentation for how to create one by using the R command `?SeqExpressionSet`. A mean-variance plot can be drawn by `meanVarPlot`.


```{r, message = FALSE, warning = FALSE, fig.align = "center", fig.height = 5, fig.width = 5}

library(EDASeq)
AMLExpressionSet <- newSeqExpressionSet(counts(dds,normalize = TRUE))
meanVarPlot(AMLExpressionSet, log = TRUE, main = "Mean-Variance Plot")

```



The red line is calculated from the data whereas the black line shows the mean and variance being the same value. Notice how the experimental variance increases at a faster rate than the mean $\equiv$ variance line, a trend commonly termed _overdispersion_.

Most classifiers require that the input data set have a constant variance across the range of means. Using DESeq2's `vst` function, remove the relationship of variance to mean. Add the normalised values into the `AMLExpressionSet` object.<br>
**Hint**: Check the documentation of `normCounts` for how to add normalised values to a `SeqExpressionSet` object.


```{r, warning = FALSE}
library(DESeq2)
dds <- estimateDispersions(dds)
measurementsVS <- assay(vst(dds))
```

Visualise again the relationship between mean and variance.

```{r, fig.align = "center", fig.height = 5, fig.width = 5}
normCounts(AMLExpressionSet) <- measurementsVS
meanVarPlot(AMLExpressionSet, xlim = c(3, 9), ylim = c(0, 9), main = "Mean-Variance Plot")
```

Notice that the variance is now fairly constant across the range of means.

Before doing any classification, the number of genes will be reduced to make feature selection faster. Keep the top 2000 most variable genes.<br>
**Hint**: Use `var` in conjunction with `apply` to calculate the variance of each row of the stabilised values. Use `?order` to check how to make the `order` function sort values in descending order.

```{r}
geneVariances <- apply(measurementsVS, 1, var)
mostVariable <- order(geneVariances, decreasing = TRUE)[1:2000]
measurementsVS <- measurementsVS[mostVariable, ]
measurementsVS[1:6, 1:6]
```

Class information is not used, so the filtering is fair. The most variable gene is XIST, a gene involved with X chromosome inactivation, a process by which one of the two copies of the X chromosome present in female mammals is inactivated.

# Simple Classification

Before the ClassifyR framework is used, simple illustrative classifications using three classifiers are done.

## Training and Test Sets

Split the samples into a training set and a test set.

```{r}
measurementsVStrain <- measurementsVS[, 1:59]
measurementsVStest <- measurementsVS[, 60:117]
clinicalTrain <- sampleInfo[1:59, ]
clinicalTest <- sampleInfo[60:117, ]
classesTrain <- classes[1:59]
classesTest <- classes[60:117]
```

## Logistic Regression

This technique is useful for classifying the clinical data as it works seamlessly with numeric and categorical data. R's `glm` function can build such a classifier if there are exactly 2 classes of samples. The `predict` function is used to make predictions for the test set samples. The option `type = "response"` specifies that probabilities should be calculated. There's no option to output class labels directly.

RUNX1-RUNX1T1 Fusion is rare and removed from the analysis because it only happens for 3 people. Every factor variable in the input table for logistic regression must have at least one observation in each class.

```{r}
fusionColumn <- match("RUNX1-RUNX1T1 Fusion", colnames(clinicalTrain))
LRclassifier <- glm(Response ~ ., "binomial", clinicalTrain[, -fusionColumn])
LRprobabilities <- predict(LRclassifier, clinicalTest[, -fusionColumn], type = "response")
LRclasses <- ifelse(LRprobabilities > 0.5, levels(classes)[2], levels(classes)[1])
LRconfusion <- table(actual = classesTest, predicted = LRclasses)
LRconfusion
```

There are `r sum(diag(LRconfusion))` samples correctly predicted and `r sum(LRconfusion) - sum(diag(LRconfusion))` samples incorrectly predicted.

## Diagnonal Linear Discriminant Analysis (DLDA)

Gene features should be chosen as the classifier performs slowly and badly if many uninformative features are present in the input table. The 10 largest absolute t-statistics will be used. `rowttests` function enables thousands of t-tests to be calculated quickly. The 10 best features are chosen for illustration; this number should be determined in a thoughtful way.

```{r, message = FALSE}
library(genefilter)
tStatistic <- rowttests(measurementsVStrain, classesTrain)[["statistic"]]
best10T <- order(abs(tStatistic), decreasing = TRUE)
```

An implementation of DLDA is provided by the R package sparsediscrim. The `dlda` function trains the classifier and the `predict` function is used to make predictions on test data. It requires that the features be the columns of the table.

```{r}
library(sparsediscrim)
DLDAclassifier <- dlda(t(measurementsVStrain[best10T, ]), classesTrain)
testResult <- predict(DLDAclassifier, t(measurementsVStest))
DLDAclasses <- testResult[["class"]]
DLDAconfusion <- table(actual = classesTest, predicted = DLDAclasses)
DLDAconfusion
```

There are `r sum(diag(DLDAconfusion))` samples correctly predicted and `r sum(DLDAconfusion) - sum(diag(DLDAconfusion))` samples incorrectly predicted.

## naive Bayes classifier

Again, feature selection is necessary. The 10 largest Kolmogorov-Smirnov test statistics will be used.

```{r, warning = FALSE}
trainSensitive <- measurementsVStrain[, classesTrain == "Sensitive"]
trainResistant <- measurementsVStrain[, classesTrain == "Resistant"]
trainSensitive <- as.list(as.data.frame(t(trainSensitive)))
trainResistant <- as.list(as.data.frame(t(trainResistant)))

KS <- mapply(function(sensValues, resValues)
                      ks.test(sensValues, resValues)[["statistic"]],
             trainSensitive, trainResistant)
best10KS <- order(abs(KS), decreasing = TRUE)
```

An implementation of naive Bayes is provided by the R package e1071. The `naiveBayes` function trains the classifier and the `predict` function is used to make predictions on test data. It requires that the features be the columns of the table.

```{r}
library(e1071)
NBclassifier <- naiveBayes(t(measurementsVStrain[best10KS, ]), classesTrain)
NBclasses <- predict(NBclassifier, t(measurementsVStest))
NBconfusion <- table(actual = classesTest, predicted = NBclasses)
NBconfusion
```

There are `r sum(diag(NBconfusion))` samples correctly predicted and `r sum(NBconfusion) - sum(diag(NBconfusion))` samples incorrectly predicted.

<span style = "font-size:34px;font-weight:300"> After the Break </span>

- Basic cross-validation

- Introduction to ClassifyR